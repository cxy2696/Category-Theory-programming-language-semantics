<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Category theory notes for programming language semantics, covering categories, functors, monads, and more.">
    <title>Category Theory in Programming Language Semantics</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad: true, theme: 'default'});</script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/haskell.min.js"></script>
    <script>hljs.highlightAll();</script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body { font-family: 'Arial', sans-serif; }
        .mermaid { margin: 1rem 0; }
        .toggle-btn { cursor: pointer; color: #3b82f6; }
        .toggle-content { display: none; }
        .toggle-content.active { display: block; }
        @media (prefers-color-scheme: dark) {
            body { background-color: #1f2937; color: #e5e7eb; }
            pre { background: #374151; }
        }
    </style>
    <script>
        // Toggle proof sections
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const content = btn.nextElementSibling;
                    content.classList.toggle('active');
                    btn.textContent = content.classList.contains('active') ? 'Hide Proof' : 'Show Proof';
                });
            });
        });
    </script>
</head>
<body class="bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-gray-100">
    <nav class="bg-blue-600 p-4 text-white" role="navigation" aria-label="Main navigation">
        <ul class="flex space-x-4">
            <li><a href="https://github.com/cxy2696/Category-Theory-programming-language-semantics" class="hover:underline" aria-label="GitHub Repository">Repository</a></li>
            <li><a href="src/CategoryBasics.hs" class="hover:underline" aria-label="Haskell Code">Code</a></li>
            <li><a href="exercises/Exercises.md" class="hover:underline" aria-label="Exercises">Exercises</a></li>
            <li><a href="https://cxy2696.github.io/Category-Theory-programming-language-semantics/categories-for-types-byRoyCrole.pdf" class="hover:underline" aria-label="Category For Types">Categories for Types by Roy Crole</a></li>
        </ul>
    </nav>
    <main class="max-w-4xl mx-auto p-6">
        <header class="mb-6">
            <h1 class="text-3xl font-bold text-blue-800 dark:text-blue-300">Category Theory for Programming Language Semantics</h1>
            <p class="mt-2">This page formalizes category theory concepts for programming language semantics, supporting denotational semantics for languages like Haskell. It covers definitions, theorems, proofs, and examples, with links to implementations in <a href="src/CategoryBasics.hs" class="text-blue-600 hover:underline">src/CategoryBasics.hs</a> and exercises in <a href="exercises/Exercises.md" class="text-blue-600 hover:underline">exercises/Exercises.md</a>.</p>
        </header>

        <section id="introduction" class="mb-8" role="region" aria-label="Introduction">
            <h2 class="text-2xl font-semibold text-blue-700 dark:text-blue-200">Introduction to Category Theory</h2>
            <p>Category theory provides a unifying language for modeling computational structures. In programming, a category abstracts types and functions, enabling formal semantics for languages like Haskell. The category <strong>Hask</strong> has Haskell types as objects (e.g., <code>Int</code>, <code>Bool</code>) and functions as morphisms (e.g., <code>length :: String -> Int</code>), with composition defined by function composition.</p>
            <p>This document aligns with the goals of <em>Category Theory in Programming Language Semantics</em>:</p>
            <ul class="list-disc pl-6">
                <li><strong>Goal (a)</strong>: Give categorical semantics to programming languages and features.</li>
                <li><strong>Goal (b)</strong>: Perform basic proofs in category theory.</li>
                <li><strong>Goal (c)</strong>: Enable further exploration of advanced applications.</li>
                <li><strong>Goal (d)</strong>: Explain denotational semantics concepts.</li>
            </ul>
        </section>

        <section id="categories" class="mb-8" role="region" aria-label="Categories">
            <h2 class="text-2xl font-semibold text-blue-700 dark:text-blue-200">Categories</h2>
            <p>A category \(\mathcal{C}\) consists of:</p>
            <ul class="list-disc pl-6">
                <li>A collection of <strong>objects</strong> (e.g., types in a programming language).</li>
                <li>For each pair of objects \(A, B \in \mathcal{C}\), a set of <strong>morphisms</strong> \(\text{Hom}_{\mathcal{C}}(A, B)\) (e.g., functions \(A \to B\)).</li>
                <li><strong>Composition</strong> \(\circ: \text{Hom}_{\mathcal{C}}(B, C) \times \text{Hom}_{\mathcal{C}}(A, B) \to \text{Hom}_{\mathcal{C}}(A, C)\).</li>
                <li>For each object \(A\), an <strong>identity morphism</strong> \(\text{id}_A \in \text{Hom}_{\mathcal{C}}(A, A)\).</li>
            </ul>
            <p>These satisfy:</p>
            <ul class="list-disc pl-6">
                <li><strong>Associativity</strong>: For \(f: A \to B\), \(g: B \to C\), \(h: C \to D\), \((h \circ g) \circ f = h \circ (g \circ f)\).</li>
                <li><strong>Identity</strong>: For \(f: A \to B\), \(f \circ \text{id}_A = f = \text{id}_B \circ f\).</li>
            </ul>
            <h3 class="text-xl font-medium mt-4">Example</h3>
            <p>In <strong>Hask</strong>, objects are Haskell types (e.g., <code>Int</code>, <code>Bool</code>), and morphisms are functions (e.g., <code>length :: String -> Int</code>). Composition is function composition, e.g., <code>(length . show) :: Int -> Int</code>.</p>
            <p><strong>Relevance</strong>:</p>
            <ul class="list-disc pl-6">
                <li><strong>Goal (a)</strong>: Categories model programming language structure, enabling semantic definitions.</li>
                <li><strong>Goal (b)</strong>: Programs are interpreted as morphisms in denotational semantics.</li>
            </ul>
        </section>

        <section id="functors" class="mb-8" role="region" aria-label="Functors">
            <h2 class="text-2xl font-semibold text-blue-700 dark:text-blue-200">Functors</h2>
            <p>A <strong>functor</strong> \(F: \mathcal{C} \to \mathcal{D}\) maps:</p>
            <ul class="list-disc pl-6">
                <li>Objects: \(A \in \mathcal{C} \mapsto F(A) \in \mathcal{D}\).</li>
                <li>Morphisms: \(f: A \to B \mapsto F(f): F(A) \to F(B)\).</li>
            </ul>
            <p>Satisfying:</p>
            <ul class="list-disc pl-6">
                <li>Identity: \(F(\text{id}_A) = \text{id}_{F(A)}\).</li>
                <li>Composition: \(F(g \circ f) = F(g) \circ F(f)\).</li>
            </ul>
            <h3 class="text-xl font-medium mt-4">Example</h3>
            <p>The <code>Maybe</code> functor in <strong>Hask</strong> maps a type <code>A</code> to <code>Maybe A</code> and a function <code>f :: A -> B</code> to:</p>
            <pre><code class="language-haskell">
fmap f :: Maybe A -> Maybe B
fmap f Nothing = Nothing
fmap f (Just x) = Just (f x)
            </code></pre>
            <h3 class="text-xl font-medium mt-4">Theorem: Functor Laws</h3>
            <p>For a functor \(F: \mathcal{C} \to \mathcal{D}\):</p>
            <ol class="list-decimal pl-6">
                <li>\(F(\text{id}_A) = \text{id}_{F(A)}\).</li>
                <li>\(F(g \circ f) = F(g) \circ F(f)\).</li>
            </ol>
            <h3 class="text-xl font-medium mt-4">Proof</h3>
            <button class="toggle-btn text-blue-600 hover:underline" aria-expanded="false">Show Proof</button>
            <div class="toggle-content">
                <p><strong>Identity</strong>: By functor definition, \(F\) preserves identities, so \(F(\text{id}_A) = \text{id}_{F(A)}\).</p>
                <p><strong>Composition</strong>: For \(f: A \to B\), \(g: B \to C\), functoriality ensures \(F(g \circ f) = F(g) \circ F(f)\).</p>
            </div>
            <p><strong>Relevance</strong>:</p>
            <ul class="list-disc pl-6">
                <li><strong>Goal (a)</strong>: Functors model type constructors for data transformations.</li>
                <li><strong>Goal (b)</strong>: Proofs verify functor properties.</li>
                <li><strong>Goal (c)</strong>: Supports denotational semantics for functional transformations.</li>
            </ul>
            <p>See <a href="src/CategoryBasics.hs" class="text-blue-600 hover:underline">src/CategoryBasics.hs</a> for <code>Maybe</code> and <code>List</code> functor implementations.</p>
        </section>

        <section id="natural-transformations" class="mb-8" role="region" aria-label="Natural Transformations">
            <h2 class="text-2xl font-semibold text-blue-700 dark:text-blue-200">Natural Transformations</h2>
            <p>A <strong>natural transformation</strong> \(\eta: F \to G\) between functors \(F, G: \mathcal{C} \to \mathcal{D}\) is a family of morphisms \(\eta_A: F(A) \to G(A)\) for each \(A \in \mathcal{C}\), such that for any \(f: A \to B\), the following diagram commutes:</p>
            <div class="mermaid">
                graph TD
                    FA[F(A)] -->|\eta_A| GA[G(A)]
                    FA -->|F(f)| FB[F(B)]
                    GA -->|G(f)| GB[G(B)]
                    FB -->|\eta_B| GB
            </div>
            <p>i.e., \(\eta_B \circ F(f) = G(f) \circ \eta_A\).</p>
            <h3 class="text-xl font-medium mt-4">Example</h3>
            <p>In <strong>Hask</strong>, <code>listToMaybe :: [a] -> Maybe a</code> is a natural transformation from the <code>List</code> functor to the <code>Maybe</code> functor:</p>
            <pre><code class="language-haskell">
listToMaybe [] = Nothing
listToMaybe (x:_) = Just x
            </code></pre>
            <h3 class="text-xl font-medium mt-4">Proof of Naturality</h3>
            <button class="toggle-btn text-blue-600 hover:underline" aria-expanded="false">Show Proof</button>
            <div class="toggle-content">
                <p>For <code>listToMaybe</code>, verify:</p>
                <pre><code class="language-haskell">
fmap f (listToMaybe xs) == listToMaybe (fmap f xs)
                </code></pre>
                <p>Left: <code>fmap f (listToMaybe []) = fmap f Nothing = Nothing</code>.</p>
                <p>Right: <code>listToMaybe (fmap f []) = listToMaybe [] = Nothing</code>.</p>
                <p>For <code>x:xs</code>, both yield <code>Just (f x)</code>.</p>
            </div>
            <p><strong>Relevance</strong>:</p>
            <ul class="list-disc pl-6">
                <li><strong>Goal (a)</strong>: Models polymorphic transformations in semantics.</li>
                <li><strong>Goal (b)</strong>: Naturality proofs build rigor.</li>
                <li><strong>Goal (c)</strong>: Ensures type-consistent program transformations.</li>
            </ul>
        </section>

        <section id="monads" class="mb-8" role="region" aria-label="Monads">
            <h2 class="text-2xl font-semibold text-blue-700 dark:text-blue-200">Monads</h2>
            <p>A <strong>monad</strong> on a category \(\mathcal{C}\) is a functor \(T: \mathcal{C} \to \mathcal{C}\) with natural transformations:</p>
            <ul class="list-disc pl-6">
                <li>Unit: \(\eta: \text{Id} \to T\).</li>
                <li>Multiplication: \(\mu: T \circ T \to T\).</li>
            </ul>
            <p>Satisfying:</p>
            <ul class="list-disc pl-6">
                <li>Left unit: \(\mu \circ T\eta = \text{id}_T\).</li>
                <li>Right unit: \(\mu \circ \eta T = \text{id}_T\).</li>
                <li>Associativity: \(\mu \circ T\mu = \mu \circ \mu T\).</li>
            </ul>
            <h3 class="text-xl font-medium mt-4">Example</h3>
            <p>The <code>State</code> monad in <strong>Hask</strong> models stateful computations:</p>
            <pre><code class="language-haskell">
return x = \s -> (x, s)
(m >>= k) s = let (a, s') = m s in k a s'
            </code></pre>
            <h3 class="text-xl font-medium mt-4">Theorem: Left Unit Law</h3>
            <p>For a monad \((T, \eta, \mu)\), \(\mu \circ T\eta = \text{id}_T\).</p>
            <h3 class="text-xl font-medium mt-4">Proof</h3>
            <button class="toggle-btn text-blue-600 hover:underline" aria-expanded="false">Show Proof</button>
            <div class="toggle-content">
                <p>For an object \(A \in \mathcal{C}\), we need \(\mu_A \circ T(\eta_A) = \text{id}_{TA}\). The commutative diagram is:</p>
                <div class="mermaid">
                    graph TD
                        TA[T(A)] -->|T(\eta_A)| T2A[T^2(A)]
                        TA -->|id_T(A)| TA2[T(A)]
                        T2A -->|\eta_A| TA2
                </div>
                <p>By the monadâ€™s unit axiom, \(\mu_A \circ T(\eta_A) = \text{id}_{TA}\). In Haskell, for <code>State</code>, <code>return</code> and <code>>>=</code> satisfy this law.</p>
            </div>
            <p><strong>Relevance</strong>:</p>
            <ul class="list-disc pl-6">
                <li><strong>Goal (a)</strong>: Monads model effects (e.g., state, I/O) in programming languages.</li>
                <li><strong>Goal (b)</strong>: Proofs verify monad properties.</li>
                <li><strong>Goal (c)</strong>: Explains denotational semantics for effectful computations.</li>
            </ul>
            <p>See <a href="src/CategoryBasics.hs" class="text-blue-600 hover:underline">src/CategoryBasics.hs</a> for <code>State</code> monad implementation.</p>
        </section>

        <section id="cccs" class="mb-8" role="region" aria-label="Cartesian Closed Categories">
            <h2 class="text-2xl font-semibold text-blue-700 dark:text-blue-200">Cartesian Closed Categories</h2>
            <p>A category \(\mathcal{C}\) is <strong>Cartesian closed</strong> if it has:</p>
            <ul class="list-disc pl-6">
                <li>A <strong>terminal object</strong> \(1\), with a unique morphism \(!: A \to 1\) for any \(A\).</li>
                <li><strong>Binary products</strong> \(A \times B\), with projections \(\pi_1: A \times B \to A\), \(\pi_2: A \times B \to B\).</li>
                <li><strong>Exponential objects</strong> \(B^A\), with evaluation \(\text{ev}: B^A \times A \to B\) and currying \(\lambda(f): C \to B^A\) for any \(f: C \times A \to B\).</li>
            </ul>
            <h3 class="text-xl font-medium mt-4">Example</h3>
            <p>In <strong>Hask</strong>, the terminal object is <code>()</code>, products are tuples <code>(A, B)</code>, and exponentials are function types <code>A -> B</code>.</p>
            <p><strong>Relevance</strong>:</p>
            <ul class="list-disc pl-6">
                <li><strong>Goal (a)</strong>: Models typed lambda calculus for functional languages.</li>
                <li><strong>Goal (b)</strong>: Explains semantics via currying and evaluation.</li>
            </ul>
        </section>

        <section id="yoneda" class="mb-8" role="region" aria-label="Yoneda Lemma">
            <h2 class="text-2xl font-semibold text-blue-700 dark:text-blue-200">Yoneda Lemma</h2>
            <h3 class="text-xl font-medium mt-4">Theorem: Yoneda Lemma</h3>
            <p>For a category \(\mathcal{C}\), object \(A\), and functor \(F: \mathcal{C} \to \mathbf{Set}\), there is a bijection:</p>
            \[
            \text{Nat}(\text{Hom}_{\mathcal{C}}(A, -), F) \cong F(A).
            \]
            <h3 class="text-xl font-medium mt-4">Proof</h3>
            <button class="toggle-btn text-blue-600 hover:underline" aria-expanded="false">Show Proof</button>
            <div class="toggle-content">
                <p>Define \(\phi: \text{Nat}(\text{Hom}_{\mathcal{C}}(A, -), F) \to F(A)\) by \(\phi(\eta) = \eta_A(\text{id}_A)\). The inverse maps \(x \in F(A)\) to \(\eta_B(f) = F(f)(x)\) for \(f: A \to B\). Naturality ensures the bijection.</p>
            </div>
            <p><strong>Relevance</strong>:</p>
            <ul class="list-disc pl-6">
                <li><strong>Goal (a)</strong>: Enables exploration of advanced type system semantics.</li>
                <li><strong>Goal (b)</strong>: Provides a theoretical tool for denotational semantics.</li>
            </ul>
        </section>
    </main>
    <footer class="bg-gray-200 dark:bg-gray-700 p-4 text-center">
        <p>Created for <em>Category Theory for Computer Scientists</em> | <a href="https://github.com/cxy2696/Category-Theory-programming-language-semantics" class="text-blue-600 hover:underline">GitHub Repository</a></p>
    </footer>
</body>
</html>
